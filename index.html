<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A.O.W.I Vision ‚Äî Screenshot-Only</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0b0e">
<style>
  :root{--bg:#0a0b0e;--panel:#101217;--edge:#1a1f2b;--ink:#f3f5fa;--mut:#9aa5b6;--gold:#f5c542;--accent:#3b82f6}
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Arial,sans-serif}
  header{position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:12px;padding:14px 16px;border-bottom:1px solid var(--edge);
    background:linear-gradient(180deg,#0a0b0e 0%,rgba(10,11,14,.92) 100%)}
  .brand{display:flex;align-items:center;gap:10px;font-weight:800}
  .dot{width:12px;height:12px;border-radius:999px;background:var(--gold);box-shadow:0 0 18px #f5c54277}
  .wrap{padding:14px;display:grid;gap:14px}
  .card{background:var(--panel);border:1px solid var(--edge);border-radius:12px;padding:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:var(--mut)}
  input,select,button,textarea{background:#0b0e14;color:var(--ink);border:1px solid #1b2330;border-radius:10px;padding:8px}
  button{background:var(--gold);color:#151515;border:none;font-weight:800;cursor:pointer}
  .ghost{background:#131828;color:#cdd7ea;border:1px solid #20273a}
  small{color:var(--mut);font-size:11px}
  .grid{display:grid;gap:10px}
  .cols-2{grid-template-columns:1fr 1fr}
  canvas{max-width:100%;height:auto;border:1px dashed #243048;border-radius:10px;background:#0b0f17}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;white-space:pre-wrap}
  .pill{display:inline-flex;gap:6px;align-items:center;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0c1220}
  .tiny{font-size:11px;color:#9aa5b6}
  .divider{height:1px;background:#1c2230;margin:8px 0}
  .hint{font-size:12px;color:#d3dcf0}
</style>
</head>
<body>
<header>
  <div class="brand"><span class="dot"></span> A.O.W.I Vision ‚Äî Screenshot-Only</div>
  <small id="state" class="tiny"></small>
</header>

<div class="wrap">

  <div class="card">
    <div class="row">
      <div class="pill">üì• Screenshots</div>
      <input id="file" type="file" accept="image/*" multiple>
      <button id="demo" class="ghost">Load Demo</button>
      <button id="analyze">Analyze</button>
      <button id="clear" class="ghost">Clear</button>
    </div>
    <small class="hint">Drop MT4/MT5 screenshots. The app OCRs the price axis, rebuilds an approximate series, computes ATR/RSI/MACD/Bollinger, and outputs actions for London/US/NY/Asia windows.</small>
    <div class="divider"></div>
    <div class="grid cols-2">
      <div class="grid">
        <label>Axis side</label>
        <select id="axisSide"><option value="right">Right</option><option value="left">Left</option></select>
        <label>Weights</label>
        <select id="weights"><option value="std">Standard</option><option value="aggr">Aggressive</option><option value="safe">Conservative</option></select>
        <small id="status">Idle.</small>
        <div id="imgs"></div>
      </div>
      <div class="grid">
        <div class="pill">üß† A.O.W.I Actions</div>
        <pre id="out" class="mono tiny"></pre>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row"><div class="pill">üîé Visualization</div></div>
    <canvas id="canvas" width="1024" height="640"></canvas>
    <small id="viz" class="tiny"></small>
  </div>

  <div class="card">
    <div class="row"><div class="pill">‚ö†Ô∏è Integrity Note</div></div>
    <small class="hint">No prediction can be guaranteed. This tool provides disciplined, rule-based actions and risk gates; outcomes remain probabilistic.</small>
  </div>

</div>

<!-- Tesseract OCR via CDN -->
<script>
let TESS_OK = false;
(function(){
  const s=document.createElement('script');
  s.src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js";
  s.onload=()=>{ TESS_OK = true; };
  s.onerror=()=>{ TESS_OK = false; };
  document.head.appendChild(s);
})();

// Register service worker for PWA/offline
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(()=>{});
  });
}
</script>

<script>
(function(){
  const $=s=>document.querySelector(s);
  const file=$('#file'), analyzeBtn=$('#analyze'), clearBtn=$('#clear'), imgs=$('#imgs'), out=$('#out'), canvas=$('#canvas'), ctx=canvas.getContext('2d');
  const statusEl=$('#status'), stateEl=$('#state'), axisSideEl=$('#axisSide'), weightsEl=$('#weights'), viz=$('#viz');
  let images=[]; let results=[];

  function drawImageFit(img){
    const scale=Math.min(canvas.width/img.width, canvas.height/img.height);
    const w=img.width*scale, h=img.height*scale;
    const x=(canvas.width-w)/2, y=(canvas.height-h)/2;
    ctx.fillStyle='#0b0f17'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,x,y,w,h);
    return {x,y,w,h,scale};
  }

  async function loadFiles(files){
    images=[]; imgs.innerHTML='';
    for(const f of files){
      const url=URL.createObjectURL(f); const img=new Image(); img.src=url; await img.decode();
      images.push({img,url});
      const el=document.createElement('img'); el.src=url; el.style.maxWidth='100%'; el.style.border='1px solid #1c2230'; el.style.borderRadius='8px'; el.style.marginBottom='8px';
      imgs.appendChild(el);
    }
    statusEl.textContent=`Loaded ${images.length} image(s).`;
  }
  file.addEventListener('change', e=>loadFiles(e.target.files));

  // Demo: synthetic candleboard
  $('#demo').addEventListener('click', ()=>{
    const w=canvas.width,h=canvas.height; ctx.fillStyle='#0b0f17'; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle='#20304a'; ctx.lineWidth=1;
    for(let i=0;i<8;i++){const y=50+i*((h-100)/7); ctx.beginPath(); ctx.moveTo(50,y); ctx.lineTo(w-50,y); ctx.stroke();}
    ctx.fillStyle='#9aa8be'; ctx.font='12px monospace';
    const p0=2350, p1=2450;
    for(let i=0;i<=7;i++){const v=p1-(p1-p0)*i/7; const y=50+i*((h-100)/7); ctx.fillText(v.toFixed(0).toString(), w-48, y-2);}
    let px=60; const maxx=w-80; let price=2410;
    const y=(v)=>50+(p1-v)/(p1-p0)*(h-100);
    while(px<maxx){
      const dir=Math.random()>0.5?1:-1; const move=(Math.random()*6);
      const open=price, close=price+dir*move, high=Math.max(open,close)+Math.random()*5, low=Math.min(open,close)-Math.random()*5;
      ctx.strokeStyle='#99b4ff'; ctx.beginPath(); ctx.moveTo(px,y(high)); ctx.lineTo(px,y(low)); ctx.stroke();
      ctx.fillStyle=close>open?'#22c55e':'#ef4444'; const top=y(Math.max(open,close)), bot=y(Math.min(open,close)); ctx.fillRect(px-3, top, 6, bot-top);
      px+=12; price=close;
    }
    canvas.toBlob(b=>{ const f=new File([b],"demo.png",{type:"image/png"}); loadFiles([f]); });
  });

  function avgColor(x0,y0,w,h){
    const img=ctx.getImageData(x0,y0,w,h).data; let r=0,g=0,b=0,n=0; for(let i=0;i<img.length;i+=4){r+=img[i];g+=img[i+1];b+=img[i+2];n++;} return [r/n,g/n,b/n];
  }
  function parseNumbers(text){
    const nums=[]; const re=/(?:\d{3,4}(?:\.\d+)?)/g; let m;
    while((m=re.exec(text))!==null){ nums.push(parseFloat(m[0])); } return nums;
  }
  function linreg(x,y){ const n=x.length; const sx=x.reduce((a,b)=>a+b,0), sy=y.reduce((a,b)=>a+b,0); const sxx=x.reduce((a,b)=>a+b*b,0), sxy=x.reduce((a,b,i)=>a+b*y[i],0); const denom=n*sxx-sx*sx||1e-6; const slope=(n*sxy-sx*sy)/denom; const intercept=(sy-slope*sx)/n; return {slope,intercept}; }
  function ema(arr,p){ const k=2/(p+1); const o=[]; let e=arr[0]; for(let i=0;i<arr.length;i++){ e=i?(arr[i]*k+e*(1-k)):arr[0]; o.push(e);} return o; }
  function sma(arr,p){ const o=[]; let s=0; for(let i=0;i<arr.length;i++){ s+=arr[i]; if(i>=p) s-=arr[i-p]; o.push(i>=p-1? s/p:arr[i]); } return o; }
  function rsi(cl,period=14){ let g=[],l=[]; for(let i=1;i<cl.length;i++){const d=cl[i]-cl[i-1]; g.push(Math.max(0,d)); l.push(Math.max(0,-d));} g=sma(g,period); l=sma(l,period); const o=[50]; for(let i=1;i<cl.length;i++){ const rs=(g[i-1]||1e-6)/(l[i-1]||1e-6); o.push(100-100/(1+rs)); } return o; }
  function macd(cl,f1=12,f2=26,s=9){ const e1=ema(cl,f1), e2=ema(cl,f2); const m=e1.map((v,i)=>v-(e2[i]||v)); const sig=ema(m,s); const h=m.map((v,i)=>v-(sig[i]||0)); return {macd:m,signal:sig,hist:h}; }
  function boll(cl,p=20,k=2){ const m=sma(cl,p); const o=[]; for(let i=0;i<cl.length;i++){ const a=Math.max(0,i-p+1), sl=cl.slice(a,i+1), mean=m[i], sd=Math.sqrt(sl.reduce((s,v)=>s+(v-mean)*(v-mean),0)/Math.max(1,sl.length)); o.push({mid:mean, upper:mean+k*sd, lower:mean-k*sd, bw:(k*sd)/(mean||1)}); } return o; }
  function atrHL(highs,lows,cl,period=14){ const tr=[]; for(let i=0;i<highs.length;i++){ if(i===0){ tr.push(highs[i]-lows[i]); } else { tr.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-cl[i-1]), Math.abs(lows[i]-cl[i-1]))); } } return sma(tr,period); }

  async function ocrYAxis(rect){
    const {x,y,w,h}=rect;
    const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx=tmp.getContext('2d'); tctx.drawImage(canvas,x,y,w,h,0,0,w,h);
    const dataURL=tmp.toDataURL('image/png');
    const { data: { text } } = await Tesseract.recognize(dataURL,'eng',{logger:()=>{}});
    const nums=parseNumbers(text).filter(v=>v>100 && v<10000);
    if(nums.length<2) return null;
    const ys=[]; const xs=[];
    for(let i=0;i<nums.length;i++){ xs.push(nums[i]); ys.push(y + (i/(nums.length-1))*h); }
    const {slope,intercept}=linreg(ys,xs); // price ‚âà slope*y + intercept
    return {slope,intercept,count:nums.length,nums};
  }

  function detectRegion(img){
    const rect=drawImageFit(img);
    const side=axisSideEl.value;
    const stripW=Math.round(rect.w*0.12);
    const x= side==='right' ? rect.x+rect.w-stripW : rect.x;
    return {rect, x, y:rect.y, w:stripW, h:rect.h};
  }

  function sampleSeries(rect){
    const {x,y,w,h}=rect;
    const step=Math.max(2, Math.floor(w/240));
    const highs=[], lows=[], closes=[], xs=[];
    const bg=avgColor(x,y,w,Math.min(20,h));
    function dist(c1,c2){return Math.hypot(c1[0]-c2[0], c1[1]-c2[1], c1[2]-c2[2]);}
    const bgThresh=30;
    for(let xi=x; xi<x+w; xi+=step){
      let hi=null, lo=null;
      for(let yi=y; yi<y+h; yi++){ const p=ctx.getImageData(xi,yi,1,1).data; if(dist([p[0],p[1],p[2]],bg)>bgThresh){ hi=yi; break; } }
      for(let yi=y+h-1; yi>=y; yi--){ const p=ctx.getImageData(xi,yi,1,1).data; if(dist([p[0],p[1],p[2]],bg)>bgThresh){ lo=yi; break; } }
      if(hi===null||lo===null) continue;
      const closeY = lo - Math.min(5, lo-y);
      highs.push(hi); lows.push(lo); closes.push(closeY); xs.push(xi);
    }
    return {xs,highs,lows,closes,step};
  }

  function structure(cl){ const n=cl.length; const X=[...Array(n).keys()]; const {slope}=linreg(X,cl); const trend = slope>0.02?'Up':(slope<-0.02?'Down':'Sideways'); return {trend,slope}; }

  function confluenceScore(k){
    const mode=weightsEl.value; const W= mode==='aggr'?{s:2,m:1}: mode==='safe'?{s:1,m:2}:{s:1.5,m:1.5};
    let s=60; if(k.squeeze) s+=8*W.m; if(k.momUp) s+=10*W.s; if(k.momDn) s+=10*W.s; if(k.rsiUp) s+=6*W.m; if(k.rsiDn) s+=6*W.m; if(k.trend==='Up'||k.trend==='Down') s+=5;
    return Math.max(0,Math.min(100,Math.round(s)));
  }

  function planFromMeasures(M){
    const tz=Intl.DateTimeFormat().resolvedOptions().timeZone||'Europe/Oslo';
    const now=new Date();
    function at(tzname,hm){
      const [H,M]=hm.split(':').map(Number); const d=new Date(now.toLocaleString('en-US',{timeZone:tzname}));
      d.setHours(H); d.setMinutes(M); d.setSeconds(0); d.setMilliseconds(0); return new Date(d.toLocaleString('en-US',{timeZone:tz}));
    }
    const wins=[
      {label:'London Open', start:at('Europe/London','08:00'), dur:120},
      {label:'US 08:30 ET Data', start:at('America/New_York','08:30'), dur:60},
      {label:'COMEX Open', start:at('America/New_York','08:20'), dur:25},
      {label:'NYSE Open', start:at('America/New_York','09:30'), dur:60},
      {label:'LBMA AM Fix', start:at('Europe/London','10:30'), dur:20},
      {label:'LBMA PM Fix', start:at('Europe/London','15:00'), dur:25},
      {label:'London Close', start:at('Europe/London','16:00'), dur:60},
      {label:'Asia Pulse', start:at('Asia/Tokyo','09:00'), dur:60},
    ];
    const lines=[];
    lines.push(`A.O.W.I Vision ‚Äî Daily/Nightly Actions (${tz})`);
    lines.push(`Regime: ${M.trend} ‚Ä¢ ATR‚âà$${M.ATR.toFixed(2)} ‚Ä¢ RSI‚âà${M.RSI.toFixed(0)} ‚Ä¢ MACD Hist‚âà${M.MACD.toFixed(2)} ‚Ä¢ BB bw‚âà${(M.BB*100).toFixed(1)}%`);
    const up=M.trend==='Up' && M.RSI>52 && M.MACD>0;
    const dn=M.trend==='Down' && M.RSI<48 && M.MACD<0;
    const squeeze=M.BB<0.015;
    const base=confluenceScore({squeeze, momUp:up, momDn:dn, rsiUp:M.RSI>55, rsiDn:M.RSI<45, trend:M.trend});
    function biasFor(label){ if(/Open|US|COMEX|NYSE/i.test(label)) return 'Breakout'; if(/Asia|Close/i.test(label)) return 'Mean-reversion'; return 'Situational'; }
    for(const w of wins){
      const end=new Date(w.start.getTime()+w.dur*60000); const bias=biasFor(w.label);
      const score=Math.max(0,Math.min(100, Math.round(base + (bias==='Breakout'?+6: bias==='Mean-reversion'?-2:0))));
      const p = Math.max(5, Math.min(95, Math.round(30 + (score-50)*0.7)));
      const hint = bias==='Breakout'
        ? (up? 'Long pullback after impulse; SL=0.8√óATR; TP1=1.2√óATR.' : dn? 'Short pullback after impulse; SL=0.8√óATR; TP1=1.2√óATR.' : 'Wait for clear impulse before entry.')
        : 'Fade BB outer tag + RSI extreme; tight stop; time-stop if no snap.';
      lines.push(`${w.label}: ${w.start.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}‚Äì${end.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} ‚Ä¢ Bias ${bias} ‚Ä¢ Score ${score} ‚Ä¢ P‚âà${p}%`);
      lines.push(`   ‚ñ∏ ${hint}`);
    }
    const contract=100, comm=5.8, spread=0.25; const tp1=1.2*M.ATR, sl=0.8*M.ATR; const lots=0.2;
    const costsPerLot = spread*contract+comm, tp1Val=tp1*contract*lots; const pass = tp1Val >= costsPerLot*lots;
    lines.push(`Cost Rule: ${pass ? 'PASS ‚úÖ' : 'FAIL ‚ùå'} ‚Ä¢ TP1‚âà$${tp1.toFixed(2)} ‚Üí $${tp1Val.toFixed(2)} vs costs $${(costsPerLot*lots).toFixed(2)} (lots ${lots})`);
    return lines.join('\n');
  }

  function detectRegion(img){
    const rect=drawImageFit(img);
    const side=axisSideEl.value;
    const stripW=Math.round(rect.w*0.12);
    const x= side==='right' ? rect.x+rect.w-stripW : rect.x;
    return {rect, x, y:rect.y, w:stripW, h:rect.h};
  }

  async function analyzeImage(img){
    const region=detectRegion(img);
    if(window.Tesseract && TESS_OK){
      try{
        statusEl.textContent='OCR axis‚Ä¶';
        const map=await ocrYAxis(region);
        if(map){
          statusEl.textContent='Extracting series‚Ä¶';
          const s=sampleSeries(region);
          const yFromPrice = (pr)=> (pr - map.intercept)/map.slope;
          const highs= s.highs.map(py=> map.slope*py + map.intercept);
          const lows = s.lows .map(py=> map.slope*py + map.intercept);
          const closes = s.closes.map(py=> map.slope*py + map.intercept);
          ctx.strokeStyle='#3b82f6'; ctx.lineWidth=1; ctx.beginPath();
          for(let i=0;i<s.xs.length;i++){ const px=s.xs[i], py=yFromPrice(closes[i]); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); } ctx.stroke();
          const ATR=atrHL(highs,lows,closes,14).pop();
          const RSI=rsi(closes,14).pop();
          const MACDv=macd(closes,12,26,9).hist.pop();
          const BB=boll(closes,20,2).pop().bw;
          viz.textContent=`OCR ok ‚Ä¢ labels ${map.count} ‚Ä¢ bars ${s.xs.length}`;
          return {ATR,RSI,MACD:MACDv,BB,trend:structure(closes).trend};
        }
      }catch(e){ /* lite mode fallback */ }
    }
    statusEl.textContent='Lite mode (no OCR) ‚Äî estimating‚Ä¶';
    const s=sampleSeries(region);
    const closesPx=s.closes; const highsPx=s.highs; const lowsPx=s.lows;
    const scale=100/(closesPx[closesPx.length-1]||100);
    const cl=closesPx.map(v=>v*scale), hi=highsPx.map(v=>v*scale), lo=lowsPx.map(v=>v*scale);
    const ATRpx=atrHL(hi,lo,cl,14).pop(); const RSI=rsi(cl,14).pop(); const MACDv=macd(cl,12,26,9).hist.pop(); const BB=boll(cl,20,2).pop().bw;
    const ATRusd = Math.max(0.5, Math.min(12, (ATRpx/2.0)*4.0));
    viz.textContent=`Lite mode ‚Ä¢ bars ${s.xs.length}`;
    return {ATR:ATRusd,RSI,MACD:MACDv,BB,trend:structure(cl).trend};
  }

  analyzeBtn.addEventListener('click', async()=>{
    try{
      if(images.length===0){ statusEl.textContent='Please select screenshot(s).'; return; }
      out.textContent=''; results=[]; stateEl.textContent='Analyzing‚Ä¶';
      for(const item of images){
        drawImageFit(item.img);
        const r=await analyzeImage(item.img);
        results.push(r);
      }
      const M=results[results.length-1];
      out.textContent = planFromMeasures(M);
      statusEl.textContent='Done.'; stateEl.textContent='Prediction generated.';
    }catch(e){ statusEl.textContent='Error: '+(e?.message||e); stateEl.textContent=''; }
  });

  clearBtn.addEventListener('click', ()=>{ images=[]; results=[]; imgs.innerHTML=''; out.textContent=''; statusEl.textContent='Cleared.'; ctx.clearRect(0,0,canvas.width,canvas.height); });

  // OCR helpers (defined below)
  async function ocrYAxis(rect){
    const {x,y,w,h}=rect;
    const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx=tmp.getContext('2d'); tctx.drawImage(canvas,x,y,w,h,0,0,w,h);
    const dataURL=tmp.toDataURL('image/png');
    const { data: { text } } = await Tesseract.recognize(dataURL,'eng',{logger:()=>{}});
    const nums=parseNumbers(text).filter(v=>v>100 && v<10000);
    if(nums.length<2) return null;
    const ys=[]; const xs=[];
    for(let i=0;i<nums.length;i++){ xs.push(nums[i]); ys.push(y + (i/(nums.length-1))*h); }
    const {slope,intercept}=linreg(ys,xs);
    return {slope,intercept,count:nums.length,nums};
  }
  function parseNumbers(text){
    const nums=[]; const re=/(?:\d{3,4}(?:\.\d+)?)/g; let m;
    while((m=re.exec(text))!==null){ nums.push(parseFloat(m[0])); } return nums;
  }

  // Math helpers
  function linreg(x,y){ const n=x.length; const sx=x.reduce((a,b)=>a+b,0), sy=y.reduce((a,b)=>a+b,0); const sxx=x.reduce((a,b)=>a+b*b,0), sxy=x.reduce((a,b,i)=>a+b*y[i],0); const denom=n*sxx-sx*sx||1e-6; const slope=(n*sxy-sx*sy)/denom; const intercept=(sy-slope*sx)/n; return {slope,intercept}; }
  function ema(arr,p){ const k=2/(p+1); const o=[]; let e=arr[0]; for(let i=0;i<arr.length;i++){ e=i?(arr[i]*k+e*(1-k)):arr[0]; o.push(e);} return o; }
  function sma(arr,p){ const o=[]; let s=0; for(let i=0;i<arr.length;i++){ s+=arr[i]; if(i>=p) s-=arr[i-p]; o.push(i>=p-1? s/p:arr[i]); } return o; }
  function rsi(cl,period=14){ let g=[],l=[]; for(let i=1;i<cl.length;i++){const d=cl[i]-cl[i-1]; g.push(Math.max(0,d)); l.push(Math.max(0,-d));} g=sma(g,period); l=sma(l,period); const o=[50]; for(let i=1;i<cl.length;i++){ const rs=(g[i-1]||1e-6)/(l[i-1]||1e-6); o.push(100-100/(1+rs)); } return o; }
  function macd(cl,f1=12,f2=26,s=9){ const e1=ema(cl,f1), e2=ema(cl,f2); const m=e1.map((v,i)=>v-(e2[i]||v)); const sig=ema(m,s); const h=m.map((v,i)=>v-(sig[i]||0)); return {macd:m,signal:sig,hist:h}; }
  function boll(cl,p=20,k=2){ const m=sma(cl,p); const o=[]; for(let i=0;i<cl.length;i++){ const a=Math.max(0,i-p+1), sl=cl.slice(a,i+1), mean=m[i], sd=Math.sqrt(sl.reduce((s,v)=>s+(v-mean)*(v-mean),0)/Math.max(1,sl.length)); o.push({mid:mean, upper:mean+k*sd, lower:mean-k*sd, bw:(k*sd)/(mean||1)}); } return o; }
  function atrHL(highs,lows,cl,period=14){ const tr=[]; for(let i=0;i<highs.length;i++){ if(i===0){ tr.push(highs[i]-lows[i]); } else { tr.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-cl[i-1]), Math.abs(lows[i]-cl[i-1]))); } } return sma(tr,period); }

})();
</script>
</body>
</html>